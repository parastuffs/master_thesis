\chapter{Implementation}
This chapter will present how we implemented the protocols of chapter~\ref{chap:theory} on the board.
The figure~\ref{fig:os-path-generic} show the generic data flow in the operating system through the user and kernel spaces.
We will first detail the software part, with the OpenVPN and openSSH as the application, and OpenSSL as a cryptographic library on which both applications rely.
Then will come strongswan, a user-space abstraction layer giving access to IPSec and we will see how different it is from an OpenVPN implementation.
Lastly, the standard Linux cryptographic kernel modules and network drivers will be listed and briefly discussed.

Before closing the chapter, we will present the two main IPs to which the cryptographic operations will be offloaded and the associated drivers.


\begin{figure}[ht]
\center
\subfloat[\label{fig:os-path-generic-a}Generic]{%
	\Large
	\resizebox{.4\linewidth}{!}{%
	\input{os-path-generic}
	}
}
\subfloat[\label{fig:os-path-generic-b}Specific]{%
	\Large
	\resizebox{.4\linewidth}{!}{%
	\input{os-path-specific}
	}
}
\caption{OS data paths}{(a) as a generic abstraction and (b) with some specific blocks replaced with custom implementations.}
\label{fig:os-path-generic}
\end{figure}

\section{Software}

\subsection{OpenVPN}
% By default, point-to-point, but since the version 2.0 can be configured in server mode, hence being able to manage hundreds of clients.
% TODO talk about the cipher none patch for version < ...

OpenVPN is widely used, and is can even integraed in some routers using packages such as DD-WRT and OpenWRT.
OpenVPN is also used by the Dutch government to secure all its communications~\cite{openvpn-nl}.

OpenVPN offers two different TUN/TAP virtual interfaces:
\begin{description}
	\item[TUN] Layer 3 IP tunnel
	\item[TAP] Layer 2 ethernet tunnel.
\end{description}


Uses regular TCP/UDP network protocols, which can be an advantage over IPSec if the ISP decides to block the latter.

Note that if one wants to use the \texttt{none} cipher with a version of OpenVPN ealier than 2.6.7, he would have to update it using a community patch~\cite{openvpn-patch-none}.


\lstset{language=c}
\begin{lstlisting}[caption=openvpn compress then encrypt -- sample from \texttt{forward.c}, label=list:openvpn-workflow]
/* Compress, fragment, encrypt and HMAC-sign an outgoing packet. */
void encrypt_sign (struct context *c, bool comp_frag)
{
	struct context_buffers *b = c->c2.buffers;
	const uint8_t *orig_buf = c->c2.buf.data;

	if (comp_frag){
	/* Compress the packet. */
		if (lzo_defined (&c->c2.lzo_compwork))
			lzo_compress (&c->c2.buf, b->lzo_compress_buf, &c->c2.lzo_compwork, &c->c2.frame);
	/* Fragment the packet. */
		if (c->c2.fragment)
			fragment_outgoing (c->c2.fragment, &c->c2.buf, &c->c2.frame_fragment);
	}

  /* Encrypt the packet and write an optional HMAC signature. */
	openvpn_encrypt (&c->c2.buf, b->encrypt_buf, &c->c2.crypto_options, &c->c2.frame);
}
\end{lstlisting}

\begin{figure}[ht]
\includegraphics[width=\textwidth]{OpenVPN-packetflow}
\caption{OpenVPN packet flow as advertized on the openVPN wiki.}{}
\label{fig:openvpn-packet-flow}
\end{figure}


\subsection{OpenSSH}
% Talk about the MAC=none patch
% connection using SSL/TLS, then AES, but without fragmentation (unlike openvpn)
OpenSSH relies on an external cryptographic library for all its security operations.
Up until the version 6.7 published in october 2014, it had to be compiled against OpenSSL.
However, after the infamous security vulnerability heartbleed in april 2014, the developpers took a step to move towards LibreSSL, a fork of OpenSSL managed by OpenBSD  developers.
Still, there is no official support for any other cryptographic library.

If OpenSSH does support most of OpenSSL ciphers by default, it takes some liberties such as disabling the CBC encryption mode and removing the support of no MAC during a transmission.

\noindent The first liberty is a laste\footnote{A vulnerability note as been issued by Carnegie Mellon University Computer Emergency Response Team in early 2009 (last revision)~\cite{CERT2009}, in response to a research of University of London~\cite{Albrecht:2009} presenting a plaintext-recovering attack against SSH when CBC mode is used, but the OpenSSH update took only place in october 2014.}.
Even if it is not recommended, the user can still enable this mode by explicitly configuring it in the \texttt{sshd\_config} options.

\noindent The second liberty has been taken to prevent the user to strip himself from data authenticity and integrity.
However, in the case of testing and benchmarking, leaving the MAC behind can be interresting, especially if it is not offloaded in hardware such as the encryption in our case.
In order to add this feature to OpenSSH, we wrote a patch to apply on OpenSSH 6.7, available in appendix~\cite{chap:openssh-patch}.




\subsection{OpenSSL}

Offers an high-level interface called EVP to be used by other applications.


It is to be noted that the present work uses an implementation with all the debug flags activated.
Figure~\ref{fig:openssl-speed-dbg-on-off} shows that if it does have an impact on the performance, it is minimal: in the worst case of the benchmark, the throughput drops only by 2.4\%.
Moreover, the benchmark maximizes this difference by doing only OpenSSL operations.
When OpenSSL will have to share the CPU with other applications, the loss will be even less noticeable.
\begin{figure}[ht]
\begin{tikzpicture}
\begin{axis}[
		title = {Openssl speed with debug on/off},
        width  = 0.85*\textwidth,
        height = 8cm,
        major x tick style = transparent,
        ybar,
        bar width=8pt,
        ymajorgrids = true,
        ylabel = {Throughput [$10^3$kB/s]},
        xlabel = {Packet size},
        ymin=0,
        symbolic x coords={16,64,256,1024,8192},
        xtick = data,
        scaled y ticks = false,%Disable the *10^4 exponent applied to all y axis markings.
        legend style={at={(0.5,-0.25)},	anchor=north,legend columns=2},
        enlarge x limits=0.1,
    ]
\addplot[style={MidnightBlue,fill=MidnightBlue,mark=none}]
	coordinates {(16,18400.60) (64,20750.61) (256,21507.33) (1024,21681.15) (8192,21725.18)};
	\label{aes-256-cbc-dbg-off}

\addplot[style={Aquamarine,fill=Aquamarine,mark=none}]
	coordinates {(16,19091.65) (64,20579.24) (256,21106.60) (1024,21216.26) (8192,21203.63)};
	\label{aes-256-cbc-dbg-on}

\addplot[style={ForestGreen,fill=ForestGreen,mark=none}]
	coordinates {(16,23882.41) (64,27781.80) (256,29285.63) (1024,29692.25) (8192,29807.96)};
	\label{aes-128-cbc-dbg-off}

\addplot[style={YellowGreen,fill=YellowGreen,mark=none}]
	coordinates {(16,23806.36) (64,27728.96) (256,29181.70) (1024,29573.46) (8192,29687.81)};
	\label{aes-128-cbc-dbg-on}

\legend{AES-256-CBC debug [off], AES-256-CBC debug [on], AES-128-CBC debug [off], AES-128-CBC debug [on]}
\end{axis}
\end{tikzpicture}
\caption{OpenSSL debugging benchmark}{Software benchmark of Openssl speed for AES mode CBC, with 128- and 256-bit keys, debugging flags (de)activated at compilation (\texttt{-fno-inline -g -marm}). The throughput difference ranges from 0.2\% and 2.4\% , and is more marked for larger keysize, as more debugging data needs to be generated.}
\label{fig:openssl-speed-dbg-on-off}
\end{figure}

% Talk about the assembly implementation, maybe show the difference in an appendice with the C implementation. Not /that/ interresting.


\subsection{Strongswan}
% TODO talk about IKE and SA management
Strongswan is a full implementation of IPSec relying on the kernel drivers for the networking part, on the crypto API for the cryptographic part, and on user space crypto libraries for the connection negociation.
An other popular implementation is ipsec-tools, but its development lags behind modern Linux and is not up-to-date with the 3.14 Linux kernel headers, making its cross-compilation painfull.
%Use strongswan 5.3.0
Strongswan as two advantages: it has a tremendous and exhaustive documentation, and its uer interface is straightforward.
Once configured, a simple \texttt{ipsec start \&\& ipsec up <connection>} on both sides is enough to create a ready to use VPN.

The figure~\ref{fig:ipsec-workflow} illustrates the workflow of Alice communicating with Bob via an IPSec ESP tunnel.
The XFRM, read ``transform", framework is implementing IPSec and handles the incomming and outgoing packets for established VPNs~\cite{rosen2014}.
Its name comes from the fact that the kernel transforms packet frames to incorporate IPSec security.
Depending on the configuration, XFRM uses the AH or ESP kernel module, which in turn calls the crypto API to encrypt and/or sign the IP packet.

We can also clearly see one of the main advantages of IPSec: it works in the kernel space.
Since it does not require a virtual network interface like OpenVPN, the only transfer between the user/kernel space happens when the former wishes to send a packet on the network, passing it to the later -- or \textit{vice versa} for incomming packets.

\begin{figure}[ht]
\Large
\resizebox{\linewidth}{!}{%
\input{ipsec-transfer}
}
\caption{IPSec user/kernel space workflow, using \texttt{ping} as a test case.}{}
\label{fig:ipsec-workflow}
\end{figure}


\subsection{Linux drivers}
% Mention the fact that we use the assembly implementation of AES, not the generic C one.
% Need an lsmod here.
Several kernel modules are needed to implement the various cryptographic algorithm in software.
The GCM alone needs five different modules, and IPSec three others.
The following description addresses all the kernel modules required to run all the use cases presented in this work.


\begin{description}
	\item[\texttt{aes\_arm}] Assembly implementation of AES. This version is optimized to use the ARMv7 instruction set.
	\item[\texttt{sha256-generic}] C implementation of SHA-256.
	\item[\texttt{gfmult128}] Multiplication in $GF(2^128)$, needed by the GCM mode.
	\item[\texttt{ghash}] GHASH function needed by the authentication of the GCM mode.
	\item[\texttt{seqiv}] Sequence IV number generator, needed by the CTR and GCM modes.
	\item[\texttt{cbc}] C based CBC mode.
	\item[\texttt{gcm}] C base GCM mode.
	\item[\texttt{crypto\_null}] Null cipher. This basically does nothing on the plaintext, but it is still needed to propose the interface in the kernel.
	\item[\texttt{tun}] TUN/TAP network device, needed by OpenVPN.
	\item[\texttt{xfrm\_user}] XFRM operations.
	\item[\texttt{esp4}] IPv4 ESP implementation. The AH counterparty is also available in the \texttt{ah4} module.
	\item[\texttt{ipcomp}] IP compression module. Needed by IPSec if the option is activated in the configuration.
	\item[\texttt{cryptodev}] Creates \texttt{/dev/crypto}, giving access to the crypto API in the user space.
	\item[\texttt{uio}] User-space I/O driver, allowing to access the hardware memory from the user space, needed by our implementation of the BA414E driver.
\end{description}

\section{Offload}

The table~\ref{tab:ip-ciphers} summarizes the ciphers supported by the two Barco Silex' IPs used in this work.

\begin{table}[ht]
\begin{tabular}{|l|c|}\hline
IP & Ciphers \\ \hline
BA414E & RSA, DH, DSA, EC \\ 
BA411E & AES modes CBC, CTR, GCM, CCM, CFB, OFB, CTS, ECB \\ \hline
\end{tabular}
\caption{Summary of the ciphers supported by two of Barco Silex' IPs.}{}
\label{tab:ip-ciphers}
\end{table}

\subsection{BA411E Driver}
Takes the rightern path, which is the cleanest because the most versatile.
By pluging the driver into the crypto API, we offer a standard kernel interface that can be used by any other kernel driver, such as the ESP driver, or user-space application via the cryptodev driver and OpenSSL engine.

However, at the current state of development, the user-space and the kernel applications do not share the same driver.
The former is using an IRQ-based driver, whilst the latter is actively polling the hardware.
The reason why the IRQ-based driver can not be used by kernel-space application is because the current implementation uses sleep methods that, when called on other kernel drivers, put the kernel in panic mode and require the system to reboot.
An alternative is under development and is further discussed in the last part of this work, in section~\ref{sec:future-work}.

Be it IRQ or polling, the inner workings are the same and follow the exact same canvas as the default software implementation the different AES modes.


\subsection{BA414E Driver and Silex engine}
At the moment of development, there is no asymetric cryptography interface in the crypto API\footnote{A request for comment patch as been submitted to the Linux kernel mailing list~\cite{crypto-api-pk-encryption} in late April 2015, proposing a standard interface for public key encryption in the crypto API.}.
The BA414E can thus not be accessed using the same path as the BA411E and a user-space driver will be needed, that is the leftern path of figure~\ref{fig:os-path-generic-b}.
As presented in section~\ref{sec:theory-driver}, we will need to rely on an UIO driver to access the device from the user space.