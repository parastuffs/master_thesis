\chapter{Technical background}

This chapter will address the technical ground inherent to this work: first the operating system, followed by the cryptography and networking.

\section{Operating system}

%User/kernel space. Networking application: need to send the data through the kernel: huge overhead.

%Crypto API

\subsection{Device Driver}\label{sec:theory-driver}
% General idea of it works
% device driver in userspace: linux userspace i/o (/dev/mem)
Userspace I/O~\cite{koch2011}

There are two ways to get the results from a hardware device: either by using interruption, or by actively polling the device, relentlessly asking it if it finished its operations.
The first case is the cleanest and the most common: when the device has something to send to the driver, or if anything unexpected happened, it sends an interruption request (IRQ) to the processor, which will in turn execute the interruption routine registered by the driver~\citep[chap. 10]{Corbet:2005:LDD:1209083}.
The second case is the easiest and is always guaranteed to work, but won't let go off the processor willingly, loading it at 100\%, and avoiding any other task to be executed.
Hopefully, modern monolithic kernels such as the Linux kernel from 2.6 provide preemptive scheduling~\cite{Santhanam2003}, that is the scheduler interrupts the running task and assigns the processor ressources it used to an other one.
Hence, systems with a lot of processes in need for CPU ressources would not be stalled, but it would not change anything if the only process heavily requesting processor time is the one using the driver.

\section{FPGA}

\section{Cryptography}

\subsection{Symetric cryptography}
Talk about encryption, integrity and authentication.


\subsubsection{AES}
Many modes, CBC is mainly used, GCM is great.

\subsubsection{SHA}
Keyed signature algorithm, several versions in place. SHA-1 is depreciated, SHA-2 is widely used and SHA-3 is already defined and begins to be implemented.

\subsection{Asymetric cryptography}
% Diffie-Hellman: show the math about the shared key, maybe from the course INFOH405 or RFC2631, and point which operation will be offloaded.
Asymetric cryptography relies on a pair of keys: one private known only to the owner of the certificate, and one public available to anyone.
Such cryptography uses two kinds of operations: encryption using the public key of the recipient and digital signature, which is an ecnryption using the private key of the sender.

\subsubsection{RSA}
RSA is a public-key scheme proposed in 1978 by three MIT researchers who gave it their name~\cite{Rivest:1978:MOD:359340.359342}.
A few years later, they founded RSA Laboratories, which is now in charge of maintaining its standards, alongside many others, as the first Public-Key Cryptography Standards, \textit{aka} PKCS \#1.
The last version of the standard is the version 2.2~\cite{pkcs1} and is defined as a precise key generation protocol allowing encryption and decryption.
The keys can be generated by respecting a few steps:
\begin{enumerate}
	\item randomy choose two large primes $p$ and $q$;
	\item compute the modulus $n = p q$, and consequently we have $\phi(n) = (p-1)(q-1)$, with $\phi(n)$ as the Euler function;
	\item randomly choose the public exponent $e \in ]1,\phi(n)[\ s.t.\ GCD(e,\phi(n)) = 1$;
	\item compute $d \in ]1,\phi(n)[\ s.t.\ e \cdot d \equiv 1 (mod\ \phi(n))$
\end{enumerate}

With those parameters, we can form a public key with the pair $(n, e)$ and a private key with the pair $(n, d)$.

The encryption and decryption of a given message $m \in \mathds{Z}_n$ are defined as follows:
\begin{description}
	\item[Encryption] $c = m^e\ mod\ n$
	\item[Decryption] $m = c^d\ mod\ n$
\end{description}




\subsubsection{Diffie-Hellman}
Diffie-Hellman is a secret key exchange protocol: two parties compute a shared secret $ZZ$ that can be used as a symetric key during the following exchanges.
It uses the same kind of operation as RSA, that is modular exponentiation.
The RFC 2631~\cite{rfc2631} decribes the protocol:

\begin{enumerate}
	\item Alice generates once $p$ and $g$ (using precomputed parameters):
	\begin{description}[nosep]
		\item[p] large prime number
		\item[g] a generator of $\mathds{Z}_p^*$
	\end{description}
	\item Alice picks a random integer $x_a$ and computes $g^{x_a} mod\ p = y_a$.
	\item Alice sends $p$, $g$ and $y_a$ to Bob, signing everything using her private certificate.
	\item Bob checks the signature and picks $x_b$.
	\item Bob computes $y_a^{x_b} mod\ p = g^{x_a x_b} mod\ p = ZZ$, the shared secret to use as a premaster key from which will be derived the symetric key for further communications.
	\item Bob sends $y_b = g^{x_b} mod\ p$, signing everything with his private certificate.
	\item Alice checks the signature and computes the same shared secret: $ZZ = y_b^{x_a} mod\ p = g^{x_a x_b} mod\ p$
\end{enumerate}

If the server is Alice, it has to do at least one signature, one signature verification and two modular exponentiations.
If the certificate use RSA, we end up with four modular exponentiations, which can become quite heavy computing wise for certain sizes of prime numbers.
We will see in chapter~\ref{chap:results} that while a 1024-bit prime is easily manageable by full software implementation, hardware offloading become a necessity for 4096-bit primes.
Moreover, 1024-bit parameter size, both RSA and Diffie-Hellman, are disallowed by the NIST recommandations since 2013~\cite{nist-sp800-131A}.

\section{Network and VPN implementation}

% Present the TCP/IP layering

% First explain what a VPN is.

There exist several major implementations of VPN: SSL, IPSec and PPTP.
The later was developped by a vendor consortium and proposed in the RFC 2637 and will not be discussed further.

\subsection{SSL/TLS}
% Introduce SSL/TLS, talk about the protocol, the key exchange and stuff, but leaver OpenVPN for the 'implementation' chapter.
% Question the security? Apparently, it does mac-then-encrypt, which is insecure regarding certain types of attacks \cite{cryptoeprint:2001:045}.
% Plus, SSLv3 is to be deprecated, according to a queued RFC: http://www.rfc-editor.org/internet-drafts/draft-ietf-tls-sslv3-diediedie-03.txt

\subsection{IPSec}
% IPSec as a protocol, strongswan come in the 'implementation' chapter.