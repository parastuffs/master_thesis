\chapter{Technical background}\label{chap:theory}

This chapter will address the technical ground inherent to this work.
First comes an overview of Linux operating systems, the distinction between user and kernel mode, and the design of device drivers.

Follow a quick presentation of FPGAs and how they can be driven from the operating system.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Operating system}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%User/kernel space. Networking application: need to send the data through the kernel: huge overhead.

%Crypto API

\subsection{Device Driver}\label{sec:theory-driver}
% General idea of it works
% device driver in userspace: linux userspace i/o (/dev/mem)
Userspace I/O~\cite{koch2011}

There are two ways to get the results from a hardware device: either by using interruption, or by actively polling the device, relentlessly asking it if it finished its operations.
The first case is the cleanest and the most common: when the device has something to send to the driver, or if anything unexpected happened, it sends an interruption request (IRQ) to the processor, which will in turn execute the interruption routine registered by the driver~\citep[chap. 10]{Corbet:2005:LDD:1209083}.
The second case is the easiest and is always guaranteed to work, but won't let go off the processor willingly, loading it at 100\%, and avoiding any other task to be executed.
Hopefully, modern monolithic kernels such as the Linux kernel from 2.6 provide preemptive scheduling~\cite{Santhanam2003}, that is the scheduler interrupts the running task and assigns the processor ressources it used to an other one.
Hence, systems with a lot of processes in need for CPU ressources would not be stalled, but it would not change anything if the only process heavily requesting processor time is the one using the driver.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FPGA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Driving from the OS: basically, they will need to share some memory.
That memory can be directly mapped and accessed from the user-space using \texttt{/dev/mem}, or can use a direct memory access module (DMA).
From the operation system, we build a bunch of scatterlist in ther kernel-space memory, then map those pages to memory descriptor that have a physical address on the DMA.
They can be mapped three different ways: \texttt{DMA\_BIDIRECTIONAL}, \texttt{DMA\_TO\_DEVICE} or \texttt{DMA\_FROM\_DEVICE}.
When the CPU write something in those descriptor and synchronize them with the DMA, it does not have to care about them anymore, the DMA in now in charge to send them to the device where registers are ready to read the incomming data.
The same goes from the device to the CPU: when the device wants to communicate data to the OS, it writes it on the DMA that will transfer them to the CPU, triggering a flag on the way to notify it.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cryptography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Cryptography is the corner stone of security.
The four main goals are the following, as defined in~\cite{Menezes1996}:
\begin{description}
	\item[Confidentiality] keeping information secret from all but those who are authorized to see it.
	\item[Integrity] ensuring information has not been altered by unauthorized or unknown means.
	\item[Source Authentication] corroborating the source of information.
	\item[Non-repudiation] preventing the denial of previous commitments or actions.
\end{description}

In order to achieve those, four cryptographic primitives are needed: symmetric and asymmetric ciphers, message digests and digital signatures.








\subsection{Message digest}
%Not the same as digital signature because we use the same key for both MAC values.
A message digest is the result of a one-way mathematical function of a fixed size.
Those hash functions are of two types~\cite{infof405}: manipulation detection codes (MDC) to guarantee integrity and message authentication codes (MAC) to guarantee both integrity and source authentication.


An MDC $h(x)$ can follow an iterative construction for a message $x$ including $t$ blocks:
\[
\begin{dcases}
	H_0 = \mbox{initial value}\\
	H_i = f(H_{i-1}, x_i), \mbox{with } i \in [1,t]\\
	h(x) = H_t\\
\end{dcases}
\]

Based on this design and adding a key to the process, the RFC 2104~\cite{rfc2104} defines a MAC:
\[
	HMAC(k, x) = h((k\oplus opad)|h((k\oplus ipad)|x))
\]
with a key $k$, and two padding block added for security concerns: an outer pad $opad$ and an inner pad $ipad$.

\noindent There exist a wide varety of MDCs, ranging from block cipher based such as Miyaguchi-Preneel, customized such as MD5, SHA-1 and SHA-2, or built using modular arithmetic such as MASH-1.

In both schemes, data integrity can be guaranteed because the flip of one bit will irremediably change the digest.
However, only a MAC can ensure source authentication since it is the only one based on a shared secret key.

Now rises the question of what and when authenticating.
\citet{Bellare2000} prooved that the most secure solution is to encrypt then compute the MAC from the ciphertext.
We will see in section~\ref{sec:theory-network} that if IPsec follows this recommandation, SSL/TLS does not and MAC first the plaintext then encrypt the message.







\subsection{Symetric cryptography}
Talk about encryption, integrity and authentication.

Look in depth into AES, NIST approved five modes~\cite{nist-sp800-38A}: CBC (Cipher Block Chaining), ECB (Electronic CodeBook), CFB (Cipher FeedBack), OFB (Output FeedBack) and CTR (Counter).

\begin{figure}
\includegraphics[width=\textwidth]{nist-cbc}
\caption{CBC encryption and decryption diagram}{taken from the NIST recommendation~\cite{nist-sp800-38A}.}
\label{fig:cbc-encrypt-decrypt}
\end{figure}

AEAD => Encryption and authentication: GCM.

\begin{figure}
\includegraphics[width=\textwidth]{nist-gcm-encrypt}
\caption{GCM encryption diagram}{taken from the NIST specification~\cite{mcgrew2005}. The ciphertext blocks are formed by \textit{xor}-ing the encrypted counter and the plaintext. The tag is generated by a chain of ciphertext \textit{xor}-ing with Galois field multiplicated data. The decryption works excatly the same way, except the plaintext and ciphertext are swapped.}
\label{fig:gcm-encrypt}
\end{figure}




\subsection{Asymetric cryptography}
% Diffie-Hellman: show the math about the shared key, maybe from the course INFOH405 or RFC2631, and point which operation will be offloaded.
Asymetric cryptography relies on a pair of keys: one private known only to the owner of the certificate, and one public available to anyone.
Such cryptography uses two kinds of operations: encryption using the public key of the recipient and digital signature, which is an ecnryption using the private key of the sender.

\subsubsection{RSA}
RSA is a public-key scheme proposed in 1978 by three MIT researchers who gave it their name~\cite{Rivest:1978:MOD:359340.359342}.
A few years later, they founded RSA Laboratories, which is now in charge of maintaining its standards, alongside many others, as the first Public-Key Cryptography Standards, \textit{aka} PKCS \#1.
The last version of the standard is the version 2.2~\cite{pkcs1} and is defined as a precise key generation protocol allowing encryption and decryption.
The keys can be generated by respecting a few steps:
\begin{enumerate}
	\item randomy choose two large primes $p$ and $q$;
	\item compute the modulus $n = p q$, and consequently we have $\phi(n) = (p-1)(q-1)$, with $\phi(n)$ as the Euler function;
	\item randomly choose the public exponent $e \in ]1,\phi(n)[\ s.t.\ GCD(e,\phi(n)) = 1$;
	\item compute $d \in ]1,\phi(n)[\ s.t.\ e \cdot d \equiv 1 (mod\ \phi(n))$
\end{enumerate}

With those parameters, we can form a public key with the pair $(n, e)$ and a private key with the pair $(n, d)$.

The encryption and decryption of a given message $m \in \mathds{Z}_n$ are defined as follows:
\begin{description}
	\item[Encryption] $c = m^e\ mod\ n$
	\item[Decryption] $m = c^d\ mod\ n$
\end{description}


\subsubsection{Diffie-Hellman}
Diffie-Hellman is a secret key exchange protocol: two parties compute a shared secret $ZZ$ that can be used as a symetric key during the following exchanges.
It uses the same kind of operation as RSA, that is modular exponentiation.
The protocol can be one of two type (\cite{rfc2631}, \cite{Frankel:2005:SGI:2206289}):
\begin{itemize}
	\item Static: the actors use their authenticated certificate to compute the shared secret.
	\item Ephemeral: the actors create a new pair of public/private keys from which the secret key is derived.
	\item Anonymous: same as ephemeral, but without signing anything, hence not identifying neither of the actors. This mode is not advisable since it's vulnerable to main-in-the-middle attack.
\end{itemize}
A static scheme is easier to implement and requires much less operations, but using ephemeral keys is essential to ensure perfect forward secrecy.
Imagine that somehow, an opponent lays his hand on the shared secret.
If that secret has already been used, he can decipher all data transfered during past connections.
However, if the secret is new for every new connection, the compromission of the shared secret des not jeopardize past communications.
This is perfect forward secrecy: using a new key to protect the past.

Hereunder is the generation of an ephemeral shared secret.
For a static secret, Alice and Bob will simply use their static certificate, sparing the modular exponentiation of the ephemeral public key generation.
\begin{enumerate}
	\item Alice generates once $p$ and $g$ (using precomputed parameters):
	\begin{description}[nosep]
		\item[p] large prime number
		\item[g] a generator of $\mathds{Z}_p^*$
	\end{description}
	\item Alice picks a random integer $x_a$ and computes $g^{x_a} mod\ p = y_a$.
	\item Alice sends $p$, $g$ and $y_a$ to Bob, signing everything using her private certificate.
	\item Bob checks the signature and picks $x_b$.
	\item Bob computes $y_a^{x_b} mod\ p = g^{x_a x_b} mod\ p = ZZ$, the shared secret to use as a premaster key from which will be derived the symetric key for further communications.
	\item Bob sends $y_b = g^{x_b} mod\ p$, signing everything with his private certificate.
	\item Alice checks the signature and computes the same shared secret: $ZZ = y_b^{x_a} mod\ p = g^{x_a x_b} mod\ p$
\end{enumerate}

If the server is Alice, it has to do at least one signature, one signature verification and two modular exponentiations.
Note that the client, B in our case, could have one signature less because RFC 5246~\cite{rfc5246} leave it as an optional feature, and the server would then have one verification less.
However, any sane configuration will have both actors signing their ephemeral public key.
If the certificate use RSA, we end up with four modular exponentiations, which can become quite heavy computing wise for certain sizes of prime numbers.
We will see in chapter~\ref{chap:results} that while a 1024-bit prime is easily manageable by full software implementation, hardware offloading become a necessity for 4096-bit primes.
Moreover, 1024-bit parameter size, both RSA and Diffie-Hellman, are disallowed by the NIST recommandations since 2013~\cite{nist-sp800-131A}.












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Network and VPN implementation}\label{sec:theory-network}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Present the TCP/IP layering
The RFC 1122~\cite{rfc1122} defines the TCP/IP and OSI stack as in the table~\ref{tab:tcp-ip-stack}.
The main difference between the two is the application layer of the TCP/IP stack which corresponds to the three upper layers of the OSI model.
Some references, such as~\citet{tanenbaum2011}, conceptually split the TCP/IP link layer into an additional physical layer.

\begin{table}[ht]
\center
\begin{tabularx}{\textwidth}{|l|l|l|X|} \hline
\multicolumn{2}{|c|}{TCP/IP layering} & \multicolumn{2}{c|}{OSI model} \\ \hline
Layer & Protocols & Layer & Protocols \\ \hline
\multirow{3}{*}{Application} & \multirow{3}{*}{FTP, SSH} & Application & FTP \\ \cline{3-4}
 & & Presentation & ASCII, JPEG \\ \cline{3-4}
 & & Session & RPC, PAP \\ \hline
Transport & TCP, UDP & Transport & TCP, UDP \\ \hline
Internet & IP, ICMP, IPsec & Network & IP, ICMP, IPsec \\ \hline
\multirow{2}{*}{Data Link} & \multirow{2}{*}{PPP, MAC, Ethernet, L2TP} & Data link & PPP, MAC, Ethernet, L2TP \\ \cline{3-4}
 & & Physical & USB, DSL, IEEE 802.11 \\ \hline
\end{tabularx}
\caption{TCP/IP and OSI model comparison}{They are globaly the same, except for the application layer of the TCP/IP stack which merge togheter the three upper layers of the OSI model. Between parenthsis are examples of protocols resting on each layer.}
\label{tab:tcp-ip-stack}
\end{table}


% First explain what a VPN is.

There exist several major implementations of VPN: SSL, IPsec, L2TP and PPTP.
The later was developped by a vendor consortium leaded by Microsoft and proposed in the RFC 2637 and will not be discussed further.

\subsection{SSL/TLS}
% Introduce SSL/TLS, talk about the protocol, the key exchange and stuff, but leaver OpenVPN for the 'implementation' chapter.
% Question the security? Apparently, it does mac-then-encrypt, which is insecure regarding certain types of attacks \cite{cryptoeprint:2001:045}.
% Plus, SSLv3 is to be deprecated, according to a queued RFC: http://www.rfc-editor.org/internet-drafts/draft-ietf-tls-sslv3-diediedie-03.txt, and is not supported anymore by many servers since poodle.
Application level security.














\subsection{IPsec}
% IPsec as a protocol, strongswan come in the 'implementation' chapter.
Modification of the IP stack in the kernel space.
IPsec is a network level security; it examines incomming IP packets and checks if there exists a security association with the destination, and decrypt it on-the-fly if necessary.

One of the main disadvantage compared to a user-space VPN is the difficulty to traverse NAT.

%TODO Figure IPsec frame structure.

\begin{figure}[ht]
\center
\subfloat[\label{fig:ipsec-transport}Transport]{%
	\large
	\resizebox{.465\linewidth}{!}{%
	\input{ipsec-transport}
	}
}
\subfloat[\label{fig:ipsec-tunnel}Tunnel]{%
	\large
	\resizebox{.535\linewidth}{!}{%
	\input{ipsec-tunnel}
	}
}
\caption{IPsec transport (a) and tunnel (b) overheads}{Tunnel mode adds a custom IP header and moves the AH/ESP header in front of the original IP header. Note: ``trl" stands for ``trailer", ``hdr" for ``header"}
\label{fig:ipsec-transport-tunnel}
\end{figure}

RFC 7321~\cite{rfc7321} defines the support for only three AES modes: CBC, CTR and GCM.





%%%%%%%%%%%%%%%%%%
% We can not invoke a verbatim environement from an other command. We thus save is inside a box and we will invoke said box later.
\newsavebox\myv

\begin{lrbox}{\myv}\begin{minipage}{\textwidth}
\begin{verbatim}
0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -----------
|               Security Parameters Index (SPI)                 |      ^Int.
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      |Cov-
|                      Sequence Number                          |      |ered
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---   | ----
|                    IV (optional)                              | ^ p  |   ^
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a  |   |
|                    Rest of Payload Data  (variable)           | | y  |Conf.
~                                                               ~ | l  |Cov-
|                                                               | | o  |ered*
+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | a  |   |
|               |         TFC Padding * (optional, variable)    | v d  |   |
+-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---   |   |
|                         |        Padding (0-255 bytes)        |      |   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      |   |
|                               |  Pad Length   | Next Header   |      v   v
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+------------
|         Integrity Check Value-ICV   (variable)                |
~                                                               ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
\end{minipage}\end{lrbox}

\begin{figure}
\center
	\resizebox{.8\linewidth}{!}{%
	\usebox\myv
	}
\caption{ESP packet structure}{as defined in RFC 4303~\cite{rfc4303}.}
\label{fig:esp-packet-structure}
\end{figure}


Don't forget to talk about the IPsec overhead from~\cite{Xenakis20063225}.