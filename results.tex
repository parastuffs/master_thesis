\chapter{Results and Analysis}\label{chap:results}

\section{TLS connections}
% Begin with the benchmark done by Bastien on the raw number of verif/s with openssl.

This benchmark is done only with OpenVPN.
Since there is no standard support for those operation in the kernel yet, it would not have made sense to use IPSec, since it would have had to fallback to OpenSSL, then following the same path as OpenVPN do.
As soon as the public key operations can be plugged into the crypto API, this use case should however be tested immediatly.


\section{Response time -- latency}
After the establishement of a connection.

\subsection{OpenVPN}

\begin{figure}[ht]
\input{graphs/openvpn-ping-benchmark}
\caption{Ping min/avg/max response time}{for different packet sizes using OpenVPN}
\label{fig:ping-benchmark-openvpn}
\end{figure}

\subsection{IPSec}

\begin{figure}[ht]
\input{graphs/ipsec-ping-benchmark}
\caption{Ping min/avg/max response time}{for different packet sizes using IPsec. For each packet size, 1000 requests were flooded to the board, that is \textit{"outputs packets as fast as they come back or one hundred times per second, whichever is more"}, according to the \texttt{ping} command manual.} %TODO move the end of the caption to the "test protocol" chapter.
\label{fig:ping-benchmark-ipsec}
\end{figure}


\section{File transfer}
%FTP over openvpn and IPSec

%OpenSSH: 	- normal transfer: shows perf difference
%			- capped to software max: show CPU offload

\subsection{openSSH}

\begin{figure}[ht]
\input{graphs/openssh-bench}
\caption{file transfer over an SSH tunnel. The background stripped bars are the CPU usage.}{}
\label{fig:openssh-bench}
\end{figure}

\subsection{OpenVPN}

\begin{figure}[ht]
\input{graphs/openvpn-ftp-bench}
\caption{FTP file transfer over an OpenVPN tunnel. The background stripped bars are the CPU usage.}{}
\label{fig:openvpn-ftp-bench}
\end{figure}

We can see that adding a MAC computation aside the encryption merely lowers the performance when using the hardware.
Even though OpenSSL uses here an hihgly ARM-optimzed assembly implementation of SHA-256, it shows that the bottleneck is on the hardware side.

Indeed, 

\subsection{IPSec}

\begin{figure}[ht]
\input{graphs/ipsec-ftp-bench}
\caption{FTP file transfer over an IPSec tunnel. The background stripped bars are the CPU usage.}{}
\label{fig:ipsec-ftp-bench}
\end{figure}

Some results have to be put into perspective with the fact that the implementation of SHA-256 is entirely C-based.
A more recent one using assembly instructions optimized for the NEON SIMD instruction set of the ARMv7 core could be used and would most probably yield better results.
The CPU usage of the software implementation would drop -- even if not significantly -- as for the hardware, it would be less limited by the software MAC counter part, and if the CPU usage could stay at the same level, we could expect a better throughput.

The GCM performance presented clearly shows a drop of throughput and an increase of CPU usage, illustrating the fact that those operations are hard on the software.
With an hardware offload, we could expect not only a drastic drop of the CPU usage, but an increase of throughput as well, since it's CPU-limited in those results.
Note that they are achieved usinf a C-based implementation of galois-field multiplications.
As we saw in chapter~\ref{chap:theory}, modern processor designers tend to add specialized instruction set aimed at AES-GCM enhancement.
Should further tests be conducted concerning IPSec paired with GCM, it would be wise to compare with an assembly implementation exploiting ARM NEON instruction set.
Some are being developed~\cite{Conrado2013,Danilo2013}, but none have been committed to the Linux kernel repository yet.

\subsection{Comparison}

\begin{figure}[ht]
\input{graphs/ftp-bench-comparison}
\caption{Comparison of file transfer methods. The background stripped bars are the CPU usage.}{}
\label{fig:ftp-bench-comparison}
\end{figure}